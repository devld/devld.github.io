<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Devld</title><link>/posts/</link><description>Recent content in Posts on Devld</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 27 Jul 2020 10:54:48 +0800</lastBuildDate><atom:link href="/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 WireGuard 无缝接入内网</title><link>/2020/07/27/wireguard-setup/</link><pubDate>Mon, 27 Jul 2020 10:54:48 +0800</pubDate><guid>/2020/07/27/wireguard-setup/</guid><description>去年心血来潮想搞个 NAS 放在家里，奈何囊肿羞涩，最终只能捡垃圾捡了个蜗牛星际，又因为种种原因吃了近一年的灰。最近又比较心血来潮，想起来了在角落中已经蒙尘的蜗牛星际。
在某宝上买的机子已经由卖家预装了黑群晖，用起来也是完全的傻瓜式操作，免去了自己折腾各种软件浪费时间。目前仅仅作为一个 samba 文件服务器，在局域网中共享一些视频或者其他资源。
OK，开始正题。现在需要支持在外面远程控制 NAS 下载一些东西。目前有这么几种方案：
直接端口映射到内网的 NAS
这种方案需要你有一个公网 IP，在路由器中将需要外网访问的端口直接映射到内网的 NAS 对应的端口上即可，操作也比较简单，速度则取决于你的上行带宽。
使用 frp 之类的内网穿透工具
这种方案需要一个拥有公网 IP 的服务器，可以将内网的端口映射到这台服务器指定的端口，在外面直接访问服务器的端口即可。具体的配置方法也比较简单，在此不再赘述，这个方案的速度却决于你的这台服务器的带宽。
直接上 VPN
这种方案也需要一个拥有公网 IP 的服务器，相较上面两种方案，这个可能不是那么的方便。但有个好处就是可以透明地访问整个内网的任意主机，速度也是取决于这台服务器的带宽。
考虑到后面可能会折腾好多东西(虽然目前就这一个)，干脆将搞个 VPN 直接支持整个内网的访问吧，这样也不用一个端口一个端口地去映射了。但缺点也显而易见，访问内网就得连接 VPN，还是有那么一点点麻烦。
那么用哪个 VPN 方案呢？
OpenVPN PPTP L2TP&amp;amp;IPSec WireGuard 先说 OpenVPN，这个安全性是毋庸置疑的，可以说是非常安全。但缺点是配置繁琐，而且性能可能不大好。
PPTP 和 L2TP 在大部分平台中都有内置，配置起来非常方便，性能也挺好的，但不是很安全。
WireGuard 是一个极其迅速而且简单的 VPN，它的目标是更快，更简单，更小，并且比 IPSec 更好用(来自 WireGuard 官网)。目前 WireGuard 已经合并进入了 Linux 内核。
可以看一下性能对比(来自 WireGuard 官网)
话不多说，开始安装吧。网络拓扑大致如下。
其中：
1.1.1.1 为服务器的公网 IP 192.168.1.0/24 为内网的 IP 段 192.168.2.0/24 为 WireGuard 的 VPN 内网网段 最终实现的效果是，电脑和手机通过连接 1.</description></item><item><title>C++ 类与类继承</title><link>/2018/03/29/cpp-learning-01/</link><pubDate>Thu, 29 Mar 2018 20:28:00 +0800</pubDate><guid>/2018/03/29/cpp-learning-01/</guid><description>构造函数与析构函数 构造函数 普通构造函数
普通构造函数用来创建对象，如果该类位定义构造函数，则编译器会生成一个默认的空参数构造函数。
复制构造函数
复制构造函数，顾名思义，用于复制一个对象，定义如下:
Test(const Test &amp;amp;t); 转换构造函数
转换构造函数，将某个类型转为这个类的类型，定义如下:
Test(const int &amp;amp;a); 使用转换构造函数可以实现类型的转换
// 调用转换构造函数，实例化一个 Test 对象 Test a = 42; 如果不希望构造函数被用于隐式转换，可用 explicit 关键字阻止隐式转换。
使用类的默认构造函数创建对象时，可能会出现下面的问题:
// 创建一个 Test 类型的变量 a Test test; // 声明了一个返回值为 Test 的函数 // 在 调用 a.fun() 时，会报错: // error: request for member &amp;#39;fun&amp;#39; in &amp;#39;a&amp;#39;, which is of non-class type &amp;#39;Test()&amp;#39; Test a(); // 动态创建对象 Test *tp = new Test(); // 销毁动态创建的对象 delete tp; 析构函数 正好与构造函数相反，用来在该对象被销毁时，释放资源。定义如下:</description></item><item><title>Ubuntu 16.04 折腾</title><link>/2018/02/14/ubuntu-beautify/</link><pubDate>Wed, 14 Feb 2018 20:34:00 +0800</pubDate><guid>/2018/02/14/ubuntu-beautify/</guid><description>卸载无用软件
sudo apt-get autoremove libreoffice-common sudo apt-get autoremove unity-webapps-common sudo apt-get autoremove thunderbird totem rhythmbox sudo apt-get autoremove simple-scan gnome-mahjongg aisleriot sudo apt-get autoremove gnome-mines cheese transmission-common gnome-orca webbrowser-app gnome-sudoku sudo apt-get autoremove onboard deja-dup 安装一些软件包
sudo apt-get install git vim curl vim
vim 配置文件 ~/.vimrc
set nocompatible filetype off syntax enable &amp;#34; Others let g:rainbow_active = 1 set laststatus=2 set fileformats=unix,dos set nowrap set nobackup set nu set ts=4 set sw=4 set expandtab set autoindent set pastetoggle=&amp;lt;f3&amp;gt; au FileType python let b:delimitMate_nesting_quotes = [&amp;#39;&amp;#34;&amp;#39;] set pastetoggle=&amp;lt;f3&amp;gt; 设置 F3 切换粘贴模式，粘贴文本时防止自动缩进</description></item><item><title>并查集(Union-Find) 判断连通性</title><link>/2017/12/27/union-find/</link><pubDate>Wed, 27 Dec 2017 10:00:00 +0800</pubDate><guid>/2017/12/27/union-find/</guid><description>有如下的一些点
每次连接其中两个点，然后判断任意两个点是否连通。
比如上图中的 0 和 1，3 和 9 等等都是连通的，而 2 和 8 不连通。
只有这么一些点，当然好判断，但如果有这么多呢
那么，如何通过算法来判断其中两个点是否是连通的呢？
如下图的状态，我们可以将其看作是三个组件(component)。
判断两个点是否连通，直接判断它们是否在同一个组件中即可。 并为每个组件设置一个 id。
设置一个数组，用来标识这个组件的 id
初始状态下，所有点都是孤立状态，所以它们所在组件的 id 就是它们本身； 当两个点被连接后，将其中一个点的_标识_更改为另一个点的_标识_； 而当连接两个组件(含一个以上的点)时，可以将其中一个组件中的所有点的标识更改为另一个组件的标识。
当判断两个点是否连接时，直接判断他们是否在同一个组件内。
定义如下的方法
public class UnionFind1 { private int[] ids; public void union(int p, int q) { int pid = ids[p]; int qid = ids[q]; for (int i = 0; i &amp;lt; ids.length; i++) { // 将所有属于 pid 的组件更换为 qid if (pid == ids[i]) { ids[i] = qid; } } } // 省略其他方法 } 测试一下</description></item><item><title>8086 汇编笔记 - 常用指令 - 03</title><link>/2017/11/16/8086-assembly-03/</link><pubDate>Thu, 16 Nov 2017 12:47:00 +0800</pubDate><guid>/2017/11/16/8086-assembly-03/</guid><description>数据传送 MOV dest, src 将 src 中的数据传送至 dest.
MOV AX, BX ; CPU 的通用寄存器之间的数据传送 MOV AX, 1234H ; 立即数 -&amp;gt; 寄存器 MOV DS:[1234H] 5678H ; 立即数 -&amp;gt; 存储单元 MOV AX, DS:[1234H] ; 存储单元 -&amp;gt; 寄存器 MOV DS:[1234H], BX ; 寄存器 -&amp;gt; 存储单元 MOV AX, ES ; 段寄存器 -&amp;gt; 通用寄存器 MOV DS, AX ; 通用寄存器 -&amp;gt; 段寄存器 MOV ES, DS:[BX] ; 存储单元 -&amp;gt; 段寄存器 MOV DS:[1234H], CS ; 段寄存器 -&amp;gt; 存储单元 MOV WORD PTR DS:[0], 12H ; 将 12H 当作 字型数据 放入 DS:[0] 使用 MOV 指令时需注意以下几点:</description></item><item><title>8086 汇编笔记 - 程序代码结构 - 02</title><link>/2017/10/29/8086-assembly-02/</link><pubDate>Sun, 29 Oct 2017 17:28:00 +0800</pubDate><guid>/2017/10/29/8086-assembly-02/</guid><description>这里的汇编是 16位汇编, 在 Win7 64位 及以后已经不支持 目前有两种方法: 一是使用虚拟机, 另外就是 安装一个 DosBox 工具合集: AsmTool.zip 包含: masm 5和6 以及 DosBox
先来一个 Hello World
ASSUME CS:CODE ; 声明代码段 DATA SEGMENT ; 数据段 HELLOWORLD DB &amp;#39;Hello World&amp;#39;, &amp;#39;$&amp;#39; ; HelloWorld 字符串 DATA ENDS STACK SEGMENT STACK ; 堆栈段 DB 32 DUP(0) ; 声明一个32 bytes的连续空间当作堆栈段 STACK ENDS CODE SEGMENT ; 代码段 START: MOV AX, DATA MOV DS, AX ; 设置 DS 为数据段 MOV AH, 09H MOV DX, OFFSET HELLOWORLD INT 21H ; 调用 DOS 的中断, 将DX 指向的字符串打印出来 MOV AX, 4C00H INT 21H ; 程序退出 CODE ENDS END START ; 汇编结束, 并表示 程序起始位置为 标号 START 处 简化版 (MASM 6.</description></item><item><title>8086 汇编笔记 - 寄存器/寻址 - 01</title><link>/2017/10/29/8086-assembly-01/</link><pubDate>Sun, 29 Oct 2017 13:46:00 +0800</pubDate><guid>/2017/10/29/8086-assembly-01/</guid><description>8086 寄存器 寄存器 说明 AX (AH+AL) 累加器(Accumulator) BX (BH+BL) 基地址寄存器(Base Register) CX (CH+CL) 计数寄存器(Count Register) DX (DH+DL) 数据寄存器(Data Register) SP 堆栈指针寄存器, 指向栈顶(高地址) BP 一般和SP 联合使用, 用于寻找堆栈数据而不破坏SP SI 源变址寄存器 DI 目的变址寄存器 CS 代码段 段寄存器 DS 数据段 段寄存器 SS 堆栈段 段寄存器 ES 附加数据段 端寄存器, 一般在复制数据时配合DS 当作目的段寄存器使用 IP 指令指针, 指向下一条指令的地址 FLAGS 标志寄存器 (见下表) 标志寄存器
标志 说明 CF 进位标志 (Carry), 如果运算的最高为产生进位或借位, 则CF=1 PF 奇偶位 (Parity), 如果运算结果的低8 位中的1的个数(二进制)为偶数个, 则PF=1 AF 辅助进位标志 (Auxiliary), 当运算结果的低4 位产生一个进位或借位, 则AF=1 ZF 零标志 (Zero), 若运算结果为0, 则ZF=1 SF 符号标志 (Signed), 当数据用补码表示时, 最高为表示符号为, SF与运算结果最高为相同 OF 溢出标志 (Overflow), 若运算中产生了溢出, 则OF=1 DF 方向标志 (Direction), 用于控制串操作指令, 如果DF=0, 则串操作过程中地址会增大, 否则地址会减小 IF 中断允许标志 (Interrupt), 若IF=0, 则CPU不能对可屏蔽中断做出响应, 否则CPU可以接受可屏蔽中断 TF 单步标志 (Trap), 如果TF=1, 则CPU按跟踪方式执行指令 数据寻址方式 立即寻址 操作数包含在指令中</description></item><item><title>《Android 开发艺术探索》笔记 - Activity - 01</title><link>/2017/10/24/android-dev-art-note-01/</link><pubDate>Tue, 24 Oct 2017 17:56:00 +0800</pubDate><guid>/2017/10/24/android-dev-art-note-01/</guid><description>Activity 生命周期 正常情况下 Activity 的生命周期 onCreate: 表示 Activity 正在被创建, 主要在这个方法中做一些初始化.
onRestart: 表示 Activity 正在重新启动, 一般情况下, 当 Activity 从不可见变为可见时会被调用.
onStart: 表示 Activity 正在启动, 但还无法与用户交互, 此时 Activity 还在后台.
onResume: 表示 Activity 已经可见了, 和 onStart 的区别是现在 Activity 处于前台.
onPause: 当其他 Activity 进入前台时会被调用, 这个方法里不能执行耗时的操作, 否则会影响新 Activity 的启动, 因为新 Activity 的 onResume 会在这个 Activity 的 onPause 执行完成后才会被调用.
onStop: 表示 Activity 即将停止, 可以做一些回收工作, 但也不能太耗时.
onDestroy: 表示 Activity 即将被销毁, 这是最后一个回调.
上图来源于: https://developer.android.google.cn/reference/android/app/Activity.html
Activity 的生命周期回调方法分为一下几种情况:
首次启动, onCreate -&amp;gt; onStart -&amp;gt; onResume.</description></item><item><title>Hello World</title><link>/2017/10/20/hello-world/</link><pubDate>Fri, 20 Oct 2017 17:00:00 +0800</pubDate><guid>/2017/10/20/hello-world/</guid><description>Hello World</description></item></channel></rss>
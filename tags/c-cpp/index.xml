<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>c-cpp on Devld</title><link>/tags/c-cpp/</link><description>Recent content in c-cpp on Devld</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 29 Mar 2018 20:28:00 +0800</lastBuildDate><atom:link href="/tags/c-cpp/index.xml" rel="self" type="application/rss+xml"/><item><title>C++ 类与类继承</title><link>/2018/03/29/cpp-learning-01/</link><pubDate>Thu, 29 Mar 2018 20:28:00 +0800</pubDate><guid>/2018/03/29/cpp-learning-01/</guid><description>构造函数与析构函数 构造函数 普通构造函数
普通构造函数用来创建对象，如果该类位定义构造函数，则编译器会生成一个默认的空参数构造函数。
复制构造函数
复制构造函数，顾名思义，用于复制一个对象，定义如下:
Test(const Test &amp;amp;t); 转换构造函数
转换构造函数，将某个类型转为这个类的类型，定义如下:
Test(const int &amp;amp;a); 使用转换构造函数可以实现类型的转换
// 调用转换构造函数，实例化一个 Test 对象 Test a = 42; 如果不希望构造函数被用于隐式转换，可用 explicit 关键字阻止隐式转换。
使用类的默认构造函数创建对象时，可能会出现下面的问题:
// 创建一个 Test 类型的变量 a Test test; // 声明了一个返回值为 Test 的函数 // 在 调用 a.fun() 时，会报错: // error: request for member &amp;#39;fun&amp;#39; in &amp;#39;a&amp;#39;, which is of non-class type &amp;#39;Test()&amp;#39; Test a(); // 动态创建对象 Test *tp = new Test(); // 销毁动态创建的对象 delete tp; 析构函数 正好与构造函数相反，用来在该对象被销毁时，释放资源。定义如下:</description></item></channel></rss>
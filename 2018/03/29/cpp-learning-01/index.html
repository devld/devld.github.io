<!doctype html><html class="not-ready text-sm lg:text-base" style=--bg:#fff lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>C++ 类与类继承 - Devld</title><meta name=theme-color><meta name=description content="构造函数与析构函数 构造函数 普通构造函数
普通构造函数用来创建对象，如果该类位定义构造函数，则编译器会生成一个默认的空参数构造函数。
复制构造函数
复制构造函数，顾名思义，用于复制一个对象，定义如下:
Test(const Test &amp;t); 转换构造函数
转换构造函数，将某个类型转为这个类的类型，定义如下:
Test(const int &amp;a); 使用转换构造函数可以实现类型的转换
// 调用转换构造函数，实例化一个 Test 对象 Test a = 42; 如果不希望构造函数被用于隐式转换，可用 explicit 关键字阻止隐式转换。
使用类的默认构造函数创建对象时，可能会出现下面的问题:
// 创建一个 Test 类型的变量 a Test test; // 声明了一个返回值为 Test 的函数 // 在 调用 a.fun() 时，会报错: // error: request for member 'fun' in 'a', which is of non-class type 'Test()' Test a(); // 动态创建对象 Test *tp = new Test(); // 销毁动态创建的对象 delete tp; 析构函数 正好与构造函数相反，用来在该对象被销毁时，释放资源。定义如下:"><meta name=author content="Devld"><link rel="preload stylesheet" as=style href=/main.min.css><script defer src=/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=preload as=image href=/theme.png><link rel=preload as=image href=/github.svg><link rel=preload as=image href=/rss.svg><link rel=icon href=/favicon.ico><link rel=apple-touch-icon href=/apple-touch-icon.png><meta name=generator content="Hugo 0.111.3"><meta property="og:title" content="C++ 类与类继承"><meta property="og:description" content="构造函数与析构函数 构造函数 普通构造函数
普通构造函数用来创建对象，如果该类位定义构造函数，则编译器会生成一个默认的空参数构造函数。
复制构造函数
复制构造函数，顾名思义，用于复制一个对象，定义如下:
Test(const Test &amp;t); 转换构造函数
转换构造函数，将某个类型转为这个类的类型，定义如下:
Test(const int &amp;a); 使用转换构造函数可以实现类型的转换
// 调用转换构造函数，实例化一个 Test 对象 Test a = 42; 如果不希望构造函数被用于隐式转换，可用 explicit 关键字阻止隐式转换。
使用类的默认构造函数创建对象时，可能会出现下面的问题:
// 创建一个 Test 类型的变量 a Test test; // 声明了一个返回值为 Test 的函数 // 在 调用 a.fun() 时，会报错: // error: request for member 'fun' in 'a', which is of non-class type 'Test()' Test a(); // 动态创建对象 Test *tp = new Test(); // 销毁动态创建的对象 delete tp; 析构函数 正好与构造函数相反，用来在该对象被销毁时，释放资源。定义如下:"><meta property="og:type" content="article"><meta property="og:url" content="/2018/03/29/cpp-learning-01/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-03-29T20:28:00+08:00"><meta property="article:modified_time" content="2018-03-29T20:28:00+08:00"><meta itemprop=name content="C++ 类与类继承"><meta itemprop=description content="构造函数与析构函数 构造函数 普通构造函数
普通构造函数用来创建对象，如果该类位定义构造函数，则编译器会生成一个默认的空参数构造函数。
复制构造函数
复制构造函数，顾名思义，用于复制一个对象，定义如下:
Test(const Test &amp;t); 转换构造函数
转换构造函数，将某个类型转为这个类的类型，定义如下:
Test(const int &amp;a); 使用转换构造函数可以实现类型的转换
// 调用转换构造函数，实例化一个 Test 对象 Test a = 42; 如果不希望构造函数被用于隐式转换，可用 explicit 关键字阻止隐式转换。
使用类的默认构造函数创建对象时，可能会出现下面的问题:
// 创建一个 Test 类型的变量 a Test test; // 声明了一个返回值为 Test 的函数 // 在 调用 a.fun() 时，会报错: // error: request for member 'fun' in 'a', which is of non-class type 'Test()' Test a(); // 动态创建对象 Test *tp = new Test(); // 销毁动态创建的对象 delete tp; 析构函数 正好与构造函数相反，用来在该对象被销毁时，释放资源。定义如下:"><meta itemprop=datePublished content="2018-03-29T20:28:00+08:00"><meta itemprop=dateModified content="2018-03-29T20:28:00+08:00"><meta itemprop=wordCount content="437"><meta itemprop=keywords content="c-cpp,notes,"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++ 类与类继承"><meta name=twitter:description content="构造函数与析构函数 构造函数 普通构造函数
普通构造函数用来创建对象，如果该类位定义构造函数，则编译器会生成一个默认的空参数构造函数。
复制构造函数
复制构造函数，顾名思义，用于复制一个对象，定义如下:
Test(const Test &amp;t); 转换构造函数
转换构造函数，将某个类型转为这个类的类型，定义如下:
Test(const int &amp;a); 使用转换构造函数可以实现类型的转换
// 调用转换构造函数，实例化一个 Test 对象 Test a = 42; 如果不希望构造函数被用于隐式转换，可用 explicit 关键字阻止隐式转换。
使用类的默认构造函数创建对象时，可能会出现下面的问题:
// 创建一个 Test 类型的变量 a Test test; // 声明了一个返回值为 Test 的函数 // 在 调用 a.fun() 时，会报错: // error: request for member 'fun' in 'a', which is of non-class type 'Test()' Test a(); // 动态创建对象 Test *tp = new Test(); // 销毁动态创建的对象 delete tp; 析构函数 正好与构造函数相反，用来在该对象被销毁时，释放资源。定义如下:"></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-0.5 text-3xl font-bold" href=/>Devld</a><div class="btn-dark text-[0] ml-6 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg=`"#fff"`.replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="mt-12 flex justify-center space-x-10 dark:invert lg:mt-0 lg:ml-12 lg:items-center lg:space-x-6"><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/devld target=_blank rel=me>github</a>
<a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./rss.svg) href=/index.xml target=_blank rel=alternate>rss</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-16 pb-24 dark:prose-invert"><article><header class=mb-20><h1 class="!my-0 pb-2.5">C++ 类与类继承</h1><div class="text-sm opacity-60"><time>2018-03-29</time>
<span class="inline-flex flex-wrap ml-6"><a class="ml-1.5 no-underline" href=/categories/c-cpp/>c-cpp</a></span></div></header><section><h3 id=构造函数与析构函数>构造函数与析构函数</h3><h4 id=构造函数>构造函数</h4><ul><li><p>普通构造函数</p><p>普通构造函数用来创建对象，如果该类位定义构造函数，则编译器会生成一个默认的空参数构造函数。</p></li><li><p>复制构造函数</p><p>复制构造函数，顾名思义，用于复制一个对象，定义如下:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#e06c75>Test</span>(<span style=color:#c678dd>const</span> <span style=color:#e06c75>Test</span> <span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>t</span>);
</span></span></code></pre></div></li><li><p>转换构造函数</p><p>转换构造函数，将某个类型转为这个类的类型，定义如下:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#e06c75>Test</span>(<span style=color:#c678dd>const</span> <span style=color:#e5c07b>int</span> <span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>a</span>);
</span></span></code></pre></div><p>使用转换构造函数可以实现类型的转换</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#7f848e>// 调用转换构造函数，实例化一个 Test 对象
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span><span style=color:#e06c75>Test</span> <span style=color:#e06c75>a</span> <span style=color:#56b6c2>=</span> <span style=color:#d19a66>42</span>;
</span></span></code></pre></div><p>如果不希望构造函数被用于隐式转换，可用 <code>explicit</code> 关键字阻止隐式转换。</p></li></ul><p>使用类的默认构造函数创建对象时，可能会出现下面的问题:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#7f848e>// 创建一个 Test 类型的变量 a
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span><span style=color:#e06c75>Test</span> <span style=color:#e06c75>test</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// 声明了一个返回值为 Test 的函数
</span></span></span><span style=display:flex><span><span style=color:#7f848e>// 在 调用 a.fun() 时，会报错: 
</span></span></span><span style=display:flex><span><span style=color:#7f848e>// error: request for member &#39;fun&#39; in &#39;a&#39;, which is of non-class type &#39;Test()&#39;
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span><span style=color:#e06c75>Test</span> <span style=color:#61afef;font-weight:700>a</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// 动态创建对象
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span><span style=color:#e06c75>Test</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>tp</span> <span style=color:#56b6c2>=</span> <span style=color:#c678dd>new</span> <span style=color:#e06c75>Test</span>();
</span></span><span style=display:flex><span><span style=color:#7f848e>// 销毁动态创建的对象
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span><span style=color:#c678dd>delete</span> <span style=color:#e06c75>tp</span>;
</span></span></code></pre></div><h4 id=析构函数>析构函数</h4><p>正好与构造函数相反，用来在该对象被销毁时，释放资源。定义如下:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#56b6c2>~</span><span style=color:#e06c75>Test</span>();
</span></span></code></pre></div><p>非动态创建的对象会在合适的时刻由编译器自动调用析构函数销毁该对象，而由 <code>new</code> 关键字创建的对象则需要手动使用 <code>delete</code> 销毁对象释放内存。</p><h3 id=运算符重载>运算符重载</h3><p>C++ 支持运算符重载，可以实现更加直观的语法，比如分数对象与分数对象的四则运算，或者在 <code>std::cout &lt;&lt;</code> 后直接跟着一个对象(重载 <code>&lt;&lt;</code>)。</p><p>定义如下:</p><pre tabindex=0><code>&lt;return_type&gt; operator&lt;op&gt;([param1, ...]);
</code></pre><h3 id=类的继承>类的继承</h3><p>C++ 属性函数的权限修饰符有三种:</p><ol><li><p>public</p><p>公开的，在任何地方都可以访问</p></li><li><p>private</p><p>私有的，只有在该类内可以访问，在子类中不可访问</p></li><li><p>protected</p><p>保护的，只有在类内和子类内可访问</p></li></ol><p>C++ 类的继承有三种模式:</p><ol><li><p>public</p><p>在子类外可以访问父类的所有 public 属性函数；
在子类内可以访问所有非 private 的父类属性函数。</p></li><li><p>private</p><p>与 public 相反，子类外不可以访问任何父类的属性及函数；
private 使父类所有成员在子类中变为 private。</p></li><li><p>protected</p><p>使父类所有 public 的成员变为 protected，类外不可访问。</p></li></ol><table><thead><tr><th style=text-align:center></th><th style=text-align:center>public 继承</th><th style=text-align:center>private 继承</th><th style=text-align:center>protected 继承</th></tr></thead><tbody><tr><td style=text-align:center>public</td><td style=text-align:center>public</td><td style=text-align:center>private</td><td style=text-align:center>protected</td></tr><tr><td style=text-align:center>private</td><td style=text-align:center>-</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:center>protected</td><td style=text-align:center>protected</td><td style=text-align:center>private</td><td style=text-align:center>protected</td></tr></tbody></table><p><em>父类的 private 属性子类永远都无权访问</em></p><h4 id=虚函数与纯虚函数>虚函数与纯虚函数</h4><h4 id=虚函数>虚函数</h4><p>看如下的代码</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#c678dd>class</span> <span style=color:#e5c07b>Base</span> {
</span></span><span style=display:flex><span><span style=color:#c678dd>public</span><span style=color:#56b6c2>:</span>
</span></span><span style=display:flex><span>    <span style=color:#e5c07b>void</span> <span style=color:#e06c75>fun</span>() {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>cout</span> <span style=color:#56b6c2>&lt;&lt;</span> <span style=color:#98c379>&#34;from base&#34;</span> <span style=color:#56b6c2>&lt;&lt;</span> <span style=color:#e06c75>endl</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>class</span> <span style=color:#e5c07b>Test</span> <span style=color:#56b6c2>:</span> <span style=color:#c678dd>public</span> <span style=color:#e06c75>Base</span> {
</span></span><span style=display:flex><span><span style=color:#c678dd>public</span><span style=color:#56b6c2>:</span>
</span></span><span style=display:flex><span>    <span style=color:#e5c07b>void</span> <span style=color:#e06c75>fun</span>() {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>cout</span> <span style=color:#56b6c2>&lt;&lt;</span> <span style=color:#98c379>&#34;from test&#34;</span> <span style=color:#56b6c2>&lt;&lt;</span> <span style=color:#e06c75>endl</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#e5c07b>int</span> <span style=color:#61afef;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#e06c75>Test</span> <span style=color:#e06c75>t</span>;
</span></span><span style=display:flex><span>    <span style=color:#e06c75>Base</span> <span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>b</span> <span style=color:#56b6c2>=</span> <span style=color:#e06c75>t</span>;
</span></span><span style=display:flex><span>    <span style=color:#e06c75>b</span>.<span style=color:#e06c75>fun</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果熟悉 Java 的话，上述代码应该会输出 <code>from test</code>，
但在 C++ 中，结果是 <code>from base</code>。</p><p>如果希望它自动调用这个对象所属类对应的函数，则需要使用虚函数</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#c678dd>class</span> <span style=color:#e5c07b>Base</span> {
</span></span><span style=display:flex><span><span style=color:#c678dd>public</span><span style=color:#56b6c2>:</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>virtual</span> <span style=color:#e5c07b>void</span> <span style=color:#e06c75>fun</span>() {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>cout</span> <span style=color:#56b6c2>&lt;&lt;</span> <span style=color:#98c379>&#34;from base&#34;</span> <span style=color:#56b6c2>&lt;&lt;</span> <span style=color:#e06c75>endl</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>为什么呢？</p><p>程序调用函数时，编译器负责将这个函数与对应的代码块联系起来，在 C++ 中，类的继承多态导致编译器无法在编译时期确定应该调用哪个函数，所以只能简单的根据 引用/指针 类型来决定调用哪个函数。这被称为 <strong>静态联编</strong>；</p><p>当这个函数被声明为 <code>virtual</code> 后，编译器将使用 <strong>动态联编</strong>，在运行时期决定调用哪个函数。</p><p>编译器在需要动态联编的类中添加了一个隐藏的成员，指向函数的指针数组，称为 <code>虚函数表</code>。其中存储了该类的所有的虚函数的地址。</p><p>当子类继承父类后，子类也会有一个虚函数表，如果子类没有为父类的虚函数提供新的定义，则该虚函数还指向父类，否则，将指向子类的函数；当子类定义了新的虚函数，这个函数的地址也会被加入到虚函数表中。</p><p>在父类中声明为 <code>virtual</code> 的函数，在其所有子类中都将是虚函数。所以，如果一个类中的某个函数可以被子类重写，最好将这个函数声明为虚函数。</p><p><strong>另外，类的构造函数不可声明虚函数，但析构函数可以，并且最好将析构函数声明为虚函数，否则，当出现上述代码的情况时，子类的析构函数将不会被调用。</strong></p><h4 id=纯虚函数>纯虚函数</h4><p>Java 中有抽象类的概念，就是不能直接实例化的类，在 C++ 中将一个类中的一个或多个函数声明为纯虚函数，也可实现相同的效果。当一个函数在父类中被声明为纯虚函数时，表明在子类中必须定义这个函数。</p><p>纯虚函数的定义方法如下</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#c678dd>class</span> <span style=color:#e5c07b>BaseClass</span> {
</span></span><span style=display:flex><span><span style=color:#c678dd>public</span><span style=color:#56b6c2>:</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>virtual</span> <span style=color:#e5c07b>void</span> <span style=color:#e06c75>fun</span>() <span style=color:#56b6c2>=</span> <span style=color:#d19a66>0</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=继承中需要注意的问题>继承中需要注意的问题</h4><p>当在子类中声明了一个与父类中某个函数同名的函数（参数不同）时，会导致父类的同名函数被覆盖掉。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#c678dd>class</span> <span style=color:#e5c07b>Base</span> {
</span></span><span style=display:flex><span><span style=color:#c678dd>public</span><span style=color:#56b6c2>:</span>
</span></span><span style=display:flex><span>    <span style=color:#e5c07b>void</span> <span style=color:#e06c75>fun</span>(<span style=color:#e5c07b>int</span> <span style=color:#e06c75>a</span>) {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>cout</span> <span style=color:#56b6c2>&lt;&lt;</span> <span style=color:#98c379>&#34;base fun: &#34;</span> <span style=color:#56b6c2>&lt;&lt;</span> <span style=color:#e06c75>a</span> <span style=color:#56b6c2>&lt;&lt;</span> <span style=color:#e06c75>endl</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#c678dd>class</span> <span style=color:#e5c07b>Test</span> {
</span></span><span style=display:flex><span><span style=color:#c678dd>public</span><span style=color:#56b6c2>:</span>
</span></span><span style=display:flex><span>    <span style=color:#e5c07b>void</span> <span style=color:#e06c75>fun</span>(<span style=color:#e06c75>string</span> <span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>str</span>) {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>cout</span> <span style=color:#56b6c2>&lt;&lt;</span> <span style=color:#98c379>&#34;test fun: &#34;</span> <span style=color:#56b6c2>&lt;&lt;</span> <span style=color:#e06c75>str</span> <span style=color:#56b6c2>&lt;&lt;</span> <span style=color:#e06c75>endl</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#e5c07b>int</span> <span style=color:#61afef;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#e06c75>Test</span> <span style=color:#e06c75>t</span>;
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// no known conversion for argument 1 from &#39;int&#39; to
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#7f848e>// &#39;std::__cxx11::string&amp; {aka std::__cxx11::basic_string&lt;char&gt;&amp;}&#39;
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e06c75>t</span>.<span style=color:#e06c75>fun</span>(<span style=color:#d19a66>123</span>);
</span></span><span style=display:flex><span>    <span style=color:#c678dd>return</span> <span style=color:#d19a66>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>重新定义不会生成两个重载的版本，而是隐藏了父类的同名函数。</p><p>所以</p><ul><li><p>当重新定义继承的函数时，应该保证函数的签名完全相同，但如果在父类中返回类型是父类的 引用/指针 则可以修改为子类的 引用/指针</p></li><li><p>如果父类中的被重新定义的函数在父类中有重载，则在子类中应该尽量重新定义所有版本</p></li></ul><p>当一个类中使用了动态内存分配后，则最好重写析构函数(用来释放内存)、复制构造函数(深拷贝) 和 重载赋值运算符(深拷贝)。</p><p>如果这个类继承自另一个类，在析构函数和复制构造函数中，编译器会自动调用其父类对应的函数，但父类的复制运算符不会被自动调用，需要我们在子类中手动调用。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#c678dd>class</span> <span style=color:#e5c07b>Child</span> {
</span></span><span style=display:flex><span><span style=color:#c678dd>public</span><span style=color:#56b6c2>:</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>Child</span> <span style=color:#56b6c2>&amp;</span><span style=color:#c678dd>operator</span><span style=color:#56b6c2>=</span>(<span style=color:#c678dd>const</span> <span style=color:#e06c75>Child</span> <span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>ch</span>) {
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// ...
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>        <span style=color:#7f848e>// 直接使用 operator=(ch); 将会进入递归死循环。
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>        <span style=color:#e06c75>Parent</span><span style=color:#56b6c2>::</span><span style=color:#c678dd>operator</span><span style=color:#56b6c2>=</span>(<span style=color:#e06c75>ch</span>);
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// ...
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=多重继承>多重继承</h3><p>C++ 支持多重继承，即一个子类可以继承自多个父类。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#c678dd>class</span> <span style=color:#e5c07b>Child</span> <span style=color:#56b6c2>:</span> <span style=color:#c678dd>public</span> <span style=color:#e06c75>ParentA</span> : <span style=color:#c678dd>public</span> <span style=color:#e06c75>ParentB</span> {
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// ...
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>};
</span></span></code></pre></div><p>这会导致一个问题</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#c678dd>class</span> <span style=color:#e5c07b>Base</span> {
</span></span><span style=display:flex><span><span style=color:#c678dd>public</span><span style=color:#56b6c2>:</span>
</span></span><span style=display:flex><span>    <span style=color:#e5c07b>void</span> <span style=color:#e06c75>fun</span>() {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>cout</span> <span style=color:#56b6c2>&lt;&lt;</span> <span style=color:#98c379>&#34;base&#34;</span> <span style=color:#56b6c2>&lt;&lt;</span> <span style=color:#e06c75>endl</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#c678dd>class</span> <span style=color:#e5c07b>ChildA</span> <span style=color:#56b6c2>:</span> <span style=color:#c678dd>public</span> <span style=color:#e06c75>Base</span> {
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#c678dd>class</span> <span style=color:#e5c07b>ChildB</span> <span style=color:#56b6c2>:</span> <span style=color:#c678dd>public</span> <span style=color:#e06c75>Base</span> {
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#c678dd>class</span> <span style=color:#e5c07b>Grandchild</span> <span style=color:#56b6c2>:</span> <span style=color:#c678dd>public</span> <span style=color:#e06c75>ChildA</span>, <span style=color:#c678dd>public</span> <span style=color:#e06c75>ChildB</span> {
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>可以看到，类 <code>Grandchild</code> 同时继承自 <code>ChildA</code> 和 <code>ChildB</code>，而它们俩又继承自 <code>Base</code>，那么当我们直接调用 <code>GrandChild::fun()</code> 时会发生什么呢？</p><pre tabindex=0><code>error: request for member &#39;fun&#39; is ambiguous
</code></pre><p>因为 <code>Grandchild</code> 继承自“两个” <code>Base</code>，一个来自 <code>ChildA</code>，另一个来自 <code>ChildB</code>，所以出现了二义性，编译器不知道该调用哪个，所以报错。</p><p>解决办法是，引入 <strong>虚基类</strong>，使 <code>ChildA</code> 和 <code>ChildB</code> <strong>虚继承</strong> 于 <code>Base</code>。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#c678dd>class</span> <span style=color:#e5c07b>ChildA</span> <span style=color:#56b6c2>:</span> <span style=color:#c678dd>virtual</span> <span style=color:#c678dd>public</span> <span style=color:#e06c75>Base</span> {
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#7f848e>// ChildB 同上
</span></span></span></code></pre></div><p>这样，当一个子类有多个相同父类时，它们中的所有从<strong>虚继承</strong>来的父类将会共用一个父类实例。</p></section><footer class="mt-12 flex flex-wrap"><a class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]" href=/tags/c-cpp/>#c-cpp</a>
<a class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]" href=/tags/notes/>#notes</a></footer><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]"><a class="flex w-1/2 items-center rounded-l-md p-6 pr-3 no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=/2020/07/27/wireguard-setup/><span class=mr-1.5>←</span><span>使用 WireGuard 无缝接入内网</span></a>
<a class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=/2018/02/14/ubuntu-beautify/><span>Ubuntu 16.04 折腾</span><span class=ml-1.5>→</span></a></nav><div class=mt-24 id=disqus_thread></div><script>const disqusShortname="devldd",script=document.createElement("script");script.src="https://"+disqusShortname+".disqus.com/embed.js",script.setAttribute("data-timestamp",+new Date),document.head.appendChild(script)</script></article></main><footer class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2023
<a class=link href=/>Devld</a></div><div class="flex gap-2"><a href=https://blog.vgbhfive.cn class=link>Vgbhfive</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Theme Paper</a></footer></body></html>
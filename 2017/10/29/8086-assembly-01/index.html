<!doctype html><html class="not-ready text-sm lg:text-base" style=--bg:#fff lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>8086 汇编笔记 - 寄存器/寻址 - 01 - Devld</title><meta name=theme-color><meta name=description content="8086 寄存器 寄存器 说明 AX (AH+AL) 累加器(Accumulator) BX (BH+BL) 基地址寄存器(Base Register) CX (CH+CL) 计数寄存器(Count Register) DX (DH+DL) 数据寄存器(Data Register) SP 堆栈指针寄存器, 指向栈顶(高地址) BP 一般和SP 联合使用, 用于寻找堆栈数据而不破坏SP SI 源变址寄存器 DI 目的变址寄存器 CS 代码段 段寄存器 DS 数据段 段寄存器 SS 堆栈段 段寄存器 ES 附加数据段 端寄存器, 一般在复制数据时配合DS 当作目的段寄存器使用 IP 指令指针, 指向下一条指令的地址 FLAGS 标志寄存器 (见下表) 标志寄存器
标志 说明 CF 进位标志 (Carry), 如果运算的最高为产生进位或借位, 则CF=1 PF 奇偶位 (Parity), 如果运算结果的低8 位中的1的个数(二进制)为偶数个, 则PF=1 AF 辅助进位标志 (Auxiliary), 当运算结果的低4 位产生一个进位或借位, 则AF=1 ZF 零标志 (Zero), 若运算结果为0, 则ZF=1 SF 符号标志 (Signed), 当数据用补码表示时, 最高为表示符号为, SF与运算结果最高为相同 OF 溢出标志 (Overflow), 若运算中产生了溢出, 则OF=1 DF 方向标志 (Direction), 用于控制串操作指令, 如果DF=0, 则串操作过程中地址会增大, 否则地址会减小 IF 中断允许标志 (Interrupt), 若IF=0, 则CPU不能对可屏蔽中断做出响应, 否则CPU可以接受可屏蔽中断 TF 单步标志 (Trap), 如果TF=1, 则CPU按跟踪方式执行指令 数据寻址方式 立即寻址 操作数包含在指令中"><meta name=author content="Devld"><link rel="preload stylesheet" as=style href=/main.min.css><script defer src=/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=preload as=image href=/theme.png><link rel=preload as=image href=/github.svg><link rel=preload as=image href=/rss.svg><link rel=icon href=/favicon.ico><link rel=apple-touch-icon href=/apple-touch-icon.png><meta name=generator content="Hugo 0.111.3"><meta property="og:title" content="8086 汇编笔记 - 寄存器/寻址 - 01"><meta property="og:description" content="8086 寄存器 寄存器 说明 AX (AH+AL) 累加器(Accumulator) BX (BH+BL) 基地址寄存器(Base Register) CX (CH+CL) 计数寄存器(Count Register) DX (DH+DL) 数据寄存器(Data Register) SP 堆栈指针寄存器, 指向栈顶(高地址) BP 一般和SP 联合使用, 用于寻找堆栈数据而不破坏SP SI 源变址寄存器 DI 目的变址寄存器 CS 代码段 段寄存器 DS 数据段 段寄存器 SS 堆栈段 段寄存器 ES 附加数据段 端寄存器, 一般在复制数据时配合DS 当作目的段寄存器使用 IP 指令指针, 指向下一条指令的地址 FLAGS 标志寄存器 (见下表) 标志寄存器
标志 说明 CF 进位标志 (Carry), 如果运算的最高为产生进位或借位, 则CF=1 PF 奇偶位 (Parity), 如果运算结果的低8 位中的1的个数(二进制)为偶数个, 则PF=1 AF 辅助进位标志 (Auxiliary), 当运算结果的低4 位产生一个进位或借位, 则AF=1 ZF 零标志 (Zero), 若运算结果为0, 则ZF=1 SF 符号标志 (Signed), 当数据用补码表示时, 最高为表示符号为, SF与运算结果最高为相同 OF 溢出标志 (Overflow), 若运算中产生了溢出, 则OF=1 DF 方向标志 (Direction), 用于控制串操作指令, 如果DF=0, 则串操作过程中地址会增大, 否则地址会减小 IF 中断允许标志 (Interrupt), 若IF=0, 则CPU不能对可屏蔽中断做出响应, 否则CPU可以接受可屏蔽中断 TF 单步标志 (Trap), 如果TF=1, 则CPU按跟踪方式执行指令 数据寻址方式 立即寻址 操作数包含在指令中"><meta property="og:type" content="article"><meta property="og:url" content="/2017/10/29/8086-assembly-01/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-10-29T13:46:00+08:00"><meta property="article:modified_time" content="2017-10-29T13:46:00+08:00"><meta itemprop=name content="8086 汇编笔记 - 寄存器/寻址 - 01"><meta itemprop=description content="8086 寄存器 寄存器 说明 AX (AH+AL) 累加器(Accumulator) BX (BH+BL) 基地址寄存器(Base Register) CX (CH+CL) 计数寄存器(Count Register) DX (DH+DL) 数据寄存器(Data Register) SP 堆栈指针寄存器, 指向栈顶(高地址) BP 一般和SP 联合使用, 用于寻找堆栈数据而不破坏SP SI 源变址寄存器 DI 目的变址寄存器 CS 代码段 段寄存器 DS 数据段 段寄存器 SS 堆栈段 段寄存器 ES 附加数据段 端寄存器, 一般在复制数据时配合DS 当作目的段寄存器使用 IP 指令指针, 指向下一条指令的地址 FLAGS 标志寄存器 (见下表) 标志寄存器
标志 说明 CF 进位标志 (Carry), 如果运算的最高为产生进位或借位, 则CF=1 PF 奇偶位 (Parity), 如果运算结果的低8 位中的1的个数(二进制)为偶数个, 则PF=1 AF 辅助进位标志 (Auxiliary), 当运算结果的低4 位产生一个进位或借位, 则AF=1 ZF 零标志 (Zero), 若运算结果为0, 则ZF=1 SF 符号标志 (Signed), 当数据用补码表示时, 最高为表示符号为, SF与运算结果最高为相同 OF 溢出标志 (Overflow), 若运算中产生了溢出, 则OF=1 DF 方向标志 (Direction), 用于控制串操作指令, 如果DF=0, 则串操作过程中地址会增大, 否则地址会减小 IF 中断允许标志 (Interrupt), 若IF=0, 则CPU不能对可屏蔽中断做出响应, 否则CPU可以接受可屏蔽中断 TF 单步标志 (Trap), 如果TF=1, 则CPU按跟踪方式执行指令 数据寻址方式 立即寻址 操作数包含在指令中"><meta itemprop=datePublished content="2017-10-29T13:46:00+08:00"><meta itemprop=dateModified content="2017-10-29T13:46:00+08:00"><meta itemprop=wordCount content="184"><meta itemprop=keywords content="汇编,notes,"><meta name=twitter:card content="summary"><meta name=twitter:title content="8086 汇编笔记 - 寄存器/寻址 - 01"><meta name=twitter:description content="8086 寄存器 寄存器 说明 AX (AH+AL) 累加器(Accumulator) BX (BH+BL) 基地址寄存器(Base Register) CX (CH+CL) 计数寄存器(Count Register) DX (DH+DL) 数据寄存器(Data Register) SP 堆栈指针寄存器, 指向栈顶(高地址) BP 一般和SP 联合使用, 用于寻找堆栈数据而不破坏SP SI 源变址寄存器 DI 目的变址寄存器 CS 代码段 段寄存器 DS 数据段 段寄存器 SS 堆栈段 段寄存器 ES 附加数据段 端寄存器, 一般在复制数据时配合DS 当作目的段寄存器使用 IP 指令指针, 指向下一条指令的地址 FLAGS 标志寄存器 (见下表) 标志寄存器
标志 说明 CF 进位标志 (Carry), 如果运算的最高为产生进位或借位, 则CF=1 PF 奇偶位 (Parity), 如果运算结果的低8 位中的1的个数(二进制)为偶数个, 则PF=1 AF 辅助进位标志 (Auxiliary), 当运算结果的低4 位产生一个进位或借位, 则AF=1 ZF 零标志 (Zero), 若运算结果为0, 则ZF=1 SF 符号标志 (Signed), 当数据用补码表示时, 最高为表示符号为, SF与运算结果最高为相同 OF 溢出标志 (Overflow), 若运算中产生了溢出, 则OF=1 DF 方向标志 (Direction), 用于控制串操作指令, 如果DF=0, 则串操作过程中地址会增大, 否则地址会减小 IF 中断允许标志 (Interrupt), 若IF=0, 则CPU不能对可屏蔽中断做出响应, 否则CPU可以接受可屏蔽中断 TF 单步标志 (Trap), 如果TF=1, 则CPU按跟踪方式执行指令 数据寻址方式 立即寻址 操作数包含在指令中"></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-0.5 text-3xl font-bold" href=/>Devld</a><div class="btn-dark text-[0] ml-6 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg=`"#fff"`.replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="mt-12 flex justify-center space-x-10 dark:invert lg:mt-0 lg:ml-12 lg:items-center lg:space-x-6"><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/devld target=_blank rel=me>github</a>
<a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./rss.svg) href=/index.xml target=_blank rel=alternate>rss</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-16 pb-24 dark:prose-invert"><article><header class=mb-20><h1 class="!my-0 pb-2.5">8086 汇编笔记 - 寄存器/寻址 - 01</h1><div class="text-sm opacity-60"><time>2017-10-29</time>
<span class="inline-flex flex-wrap ml-6"><a class="ml-1.5 no-underline" href=/categories/%E6%B1%87%E7%BC%96/>汇编</a></span></div></header><section><h3 id=8086-寄存器>8086 寄存器</h3><table><thead><tr><th>寄存器</th><th>说明</th></tr></thead><tbody><tr><td>AX (AH+AL)</td><td>累加器(Accumulator)</td></tr><tr><td>BX (BH+BL)</td><td>基地址寄存器(Base Register)</td></tr><tr><td>CX (CH+CL)</td><td>计数寄存器(Count Register)</td></tr><tr><td>DX (DH+DL)</td><td>数据寄存器(Data Register)</td></tr><tr><td>SP</td><td>堆栈指针寄存器, 指向栈顶(高地址)</td></tr><tr><td>BP</td><td>一般和SP 联合使用, 用于寻找堆栈数据而不破坏SP</td></tr><tr><td>SI</td><td>源变址寄存器</td></tr><tr><td>DI</td><td>目的变址寄存器</td></tr><tr><td>CS</td><td>代码段 段寄存器</td></tr><tr><td>DS</td><td>数据段 段寄存器</td></tr><tr><td>SS</td><td>堆栈段 段寄存器</td></tr><tr><td>ES</td><td>附加数据段 端寄存器, 一般在复制数据时配合DS 当作目的段寄存器使用</td></tr><tr><td>IP</td><td>指令指针, 指向下一条指令的地址</td></tr><tr><td>FLAGS</td><td>标志寄存器 (见下表)</td></tr></tbody></table><p>标志寄存器</p><table><thead><tr><th>标志</th><th>说明</th></tr></thead><tbody><tr><td>CF</td><td>进位标志 (Carry), 如果运算的最高为产生进位或借位, 则CF=1</td></tr><tr><td>PF</td><td>奇偶位 (Parity), 如果运算结果的低8 位中的1的个数(二进制)为偶数个, 则PF=1</td></tr><tr><td>AF</td><td>辅助进位标志 (Auxiliary), 当运算结果的低4 位产生一个进位或借位, 则AF=1</td></tr><tr><td>ZF</td><td>零标志 (Zero), 若运算结果为0, 则ZF=1</td></tr><tr><td>SF</td><td>符号标志 (Signed), 当数据用补码表示时, 最高为表示符号为, SF与运算结果最高为相同</td></tr><tr><td>OF</td><td>溢出标志 (Overflow), 若运算中产生了溢出, 则OF=1</td></tr><tr><td>DF</td><td>方向标志 (Direction), 用于控制串操作指令, 如果DF=0, 则串操作过程中地址会增大, 否则地址会减小</td></tr><tr><td>IF</td><td>中断允许标志 (Interrupt), 若IF=0, 则CPU不能对可屏蔽中断做出响应, 否则CPU可以接受可屏蔽中断</td></tr><tr><td>TF</td><td>单步标志 (Trap), 如果TF=1, 则CPU按跟踪方式执行指令</td></tr></tbody></table><p><img src=8086-flags-reg.png alt=flags></p><h3 id=数据寻址方式>数据寻址方式</h3><ol><li>立即寻址</li></ol><p>操作数包含在指令中</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>MOV AX, 1234H    ; 将 1234H 存入寄存器AX, （AH = 12H, AL = 34H）
</code></pre><ol start=2><li>寄存器寻址</li></ol><p>数据存放在寄存器中</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>MOV AX, 1234H
MOV AX, BX      ; 将BX中的数据放入AX
</code></pre><ol start=3><li>直接寻址</li></ol><p>数据在内存中, 将数据所在的 16位偏移地址用方括号括起来
默认使用DS 段寄存器
对应的物理地址计算方法为: <code>段地址 * 10H + 偏移地址</code></p><p>假设 <code>DS = 2000H</code>
那么 <code>MOV AX, [1000H]</code> 读取的物理地址是:
<code>2000H * 10H + 1000H = 21000H</code>
表示将 物理地址 <code>21000H</code> 里的一个字型数据放到AX中</p><p>假设<code>2000H:1000H</code>位置保存的数据为 <code>1234H</code>, 如下图
<img src=mem-2000h-1000h.png alt=2000H:1000H></p><p>则<code>MOV AX, [1000H]</code>会将<code>34H</code>放入AH, <code>12H</code>放入AL. 即高位地址的数据存放在AX高位, 低位存在低位
<img src=mov-ax-1000h.png alt="MOV AX, \[1000H\]"></p><ol start=4><li>寄存器间接寻址</li></ol><p>数据在内存中的地址存放在寄存器中</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>MOV AX, [BX]
</code></pre><ol start=5><li>相对寄存器寻址</li></ol><p>可以在偏移地址中再指定偏移量</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>MOV AX, [BX+2H]
MOV AX, [BX+SI+2H]
</code></pre></section><footer class="mt-12 flex flex-wrap"><a class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]" href=/tags/%E6%B1%87%E7%BC%96/>#汇编</a>
<a class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]" href=/tags/notes/>#notes</a></footer><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]"><a class="flex w-1/2 items-center rounded-l-md p-6 pr-3 no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=/2017/10/29/8086-assembly-02/><span class=mr-1.5>←</span><span>8086 汇编笔记 - 程序代码结构 - 02</span></a>
<a class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=/2017/10/24/android-dev-art-note-01/><span>《Android 开发艺术探索》笔记 - Activity - 01</span><span class=ml-1.5>→</span></a></nav><div class=mt-24 id=disqus_thread></div><script>const disqusShortname="devldd",script=document.createElement("script");script.src="https://"+disqusShortname+".disqus.com/embed.js",script.setAttribute("data-timestamp",+new Date),document.head.appendChild(script)</script></article></main><footer class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2023
<a class=link href=/>Devld</a></div><div class="flex gap-2"><a href=https://blog.vgbhfive.cn class=link>Vgbhfive</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Theme Paper</a></footer></body></html>
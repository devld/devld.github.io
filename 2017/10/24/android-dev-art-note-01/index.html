<!doctype html><html class="not-ready text-sm lg:text-base" style=--bg:#fff lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>《Android 开发艺术探索》笔记 - Activity - 01 - Devld</title><meta name=theme-color><meta name=description content="Activity 生命周期 正常情况下 Activity 的生命周期 onCreate: 表示 Activity 正在被创建, 主要在这个方法中做一些初始化.
onRestart: 表示 Activity 正在重新启动, 一般情况下, 当 Activity 从不可见变为可见时会被调用.
onStart: 表示 Activity 正在启动, 但还无法与用户交互, 此时 Activity 还在后台.
onResume: 表示 Activity 已经可见了, 和 onStart 的区别是现在 Activity 处于前台.
onPause: 当其他 Activity 进入前台时会被调用, 这个方法里不能执行耗时的操作, 否则会影响新 Activity 的启动, 因为新 Activity 的 onResume 会在这个 Activity 的 onPause 执行完成后才会被调用.
onStop: 表示 Activity 即将停止, 可以做一些回收工作, 但也不能太耗时.
onDestroy: 表示 Activity 即将被销毁, 这是最后一个回调.
上图来源于: https://developer.android.google.cn/reference/android/app/Activity.html
Activity 的生命周期回调方法分为一下几种情况:
首次启动, onCreate -> onStart -> onResume."><meta name=author content="Devld"><link rel="preload stylesheet" as=style href=/main.min.css><script defer src=highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=preload as=image href=theme.png><link rel=preload as=image href=github.svg><link rel=preload as=image href=rss.svg><link rel=icon href=favicon.ico><link rel=apple-touch-icon href=apple-touch-icon.png><meta name=generator content="Hugo 0.111.3"><meta property="og:title" content="《Android 开发艺术探索》笔记 - Activity - 01"><meta property="og:description" content="Activity 生命周期 正常情况下 Activity 的生命周期 onCreate: 表示 Activity 正在被创建, 主要在这个方法中做一些初始化.
onRestart: 表示 Activity 正在重新启动, 一般情况下, 当 Activity 从不可见变为可见时会被调用.
onStart: 表示 Activity 正在启动, 但还无法与用户交互, 此时 Activity 还在后台.
onResume: 表示 Activity 已经可见了, 和 onStart 的区别是现在 Activity 处于前台.
onPause: 当其他 Activity 进入前台时会被调用, 这个方法里不能执行耗时的操作, 否则会影响新 Activity 的启动, 因为新 Activity 的 onResume 会在这个 Activity 的 onPause 执行完成后才会被调用.
onStop: 表示 Activity 即将停止, 可以做一些回收工作, 但也不能太耗时.
onDestroy: 表示 Activity 即将被销毁, 这是最后一个回调.
上图来源于: https://developer.android.google.cn/reference/android/app/Activity.html
Activity 的生命周期回调方法分为一下几种情况:
首次启动, onCreate -> onStart -> onResume."><meta property="og:type" content="article"><meta property="og:url" content="/2017/10/24/android-dev-art-note-01/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-10-24T17:56:00+08:00"><meta property="article:modified_time" content="2017-10-24T17:56:00+08:00"><meta itemprop=name content="《Android 开发艺术探索》笔记 - Activity - 01"><meta itemprop=description content="Activity 生命周期 正常情况下 Activity 的生命周期 onCreate: 表示 Activity 正在被创建, 主要在这个方法中做一些初始化.
onRestart: 表示 Activity 正在重新启动, 一般情况下, 当 Activity 从不可见变为可见时会被调用.
onStart: 表示 Activity 正在启动, 但还无法与用户交互, 此时 Activity 还在后台.
onResume: 表示 Activity 已经可见了, 和 onStart 的区别是现在 Activity 处于前台.
onPause: 当其他 Activity 进入前台时会被调用, 这个方法里不能执行耗时的操作, 否则会影响新 Activity 的启动, 因为新 Activity 的 onResume 会在这个 Activity 的 onPause 执行完成后才会被调用.
onStop: 表示 Activity 即将停止, 可以做一些回收工作, 但也不能太耗时.
onDestroy: 表示 Activity 即将被销毁, 这是最后一个回调.
上图来源于: https://developer.android.google.cn/reference/android/app/Activity.html
Activity 的生命周期回调方法分为一下几种情况:
首次启动, onCreate -> onStart -> onResume."><meta itemprop=datePublished content="2017-10-24T17:56:00+08:00"><meta itemprop=dateModified content="2017-10-24T17:56:00+08:00"><meta itemprop=wordCount content="600"><meta itemprop=keywords content="android,notes,"><meta name=twitter:card content="summary"><meta name=twitter:title content="《Android 开发艺术探索》笔记 - Activity - 01"><meta name=twitter:description content="Activity 生命周期 正常情况下 Activity 的生命周期 onCreate: 表示 Activity 正在被创建, 主要在这个方法中做一些初始化.
onRestart: 表示 Activity 正在重新启动, 一般情况下, 当 Activity 从不可见变为可见时会被调用.
onStart: 表示 Activity 正在启动, 但还无法与用户交互, 此时 Activity 还在后台.
onResume: 表示 Activity 已经可见了, 和 onStart 的区别是现在 Activity 处于前台.
onPause: 当其他 Activity 进入前台时会被调用, 这个方法里不能执行耗时的操作, 否则会影响新 Activity 的启动, 因为新 Activity 的 onResume 会在这个 Activity 的 onPause 执行完成后才会被调用.
onStop: 表示 Activity 即将停止, 可以做一些回收工作, 但也不能太耗时.
onDestroy: 表示 Activity 即将被销毁, 这是最后一个回调.
上图来源于: https://developer.android.google.cn/reference/android/app/Activity.html
Activity 的生命周期回调方法分为一下几种情况:
首次启动, onCreate -> onStart -> onResume."></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-0.5 text-3xl font-bold" href=/>Devld</a><div class="btn-dark text-[0] ml-6 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg=`"#fff"`.replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="mt-12 flex justify-center space-x-10 dark:invert lg:mt-0 lg:ml-12 lg:items-center lg:space-x-6"><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/devld target=_blank rel=me>github</a>
<a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./rss.svg) href=index.xml target=_blank rel=alternate>rss</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-16 pb-24 dark:prose-invert"><article><header class=mb-20><h1 class="!my-0 pb-2.5">《Android 开发艺术探索》笔记 - Activity - 01</h1><div class="text-sm opacity-60"><time>2017-10-24</time>
<span class="inline-flex flex-wrap ml-6"><a class="ml-1.5 no-underline" href=categories/android/>Android</a></span></div></header><section><h3 id=activity-生命周期>Activity 生命周期</h3><h4 id=正常情况下-activity-的生命周期>正常情况下 Activity 的生命周期</h4><ol><li><p><strong>onCreate</strong>: 表示 Activity 正在被创建, 主要在这个方法中做一些初始化.</p></li><li><p><strong>onRestart</strong>: 表示 Activity 正在重新启动, 一般情况下, 当 Activity 从不可见变为可见时会被调用.</p></li><li><p><strong>onStart</strong>: 表示 Activity 正在启动, 但还无法与用户交互, 此时 Activity 还在后台.</p></li><li><p><strong>onResume</strong>: 表示 Activity 已经可见了, 和 onStart 的区别是现在 Activity 处于前台.</p></li><li><p><strong>onPause</strong>: 当其他 Activity 进入前台时会被调用, 这个方法里不能执行耗时的操作, 否则会影响新 Activity 的启动, 因为新 Activity 的 onResume 会在这个 Activity 的 onPause 执行完成后才会被调用.</p></li><li><p><strong>onStop</strong>: 表示 Activity 即将停止, 可以做一些回收工作, 但也不能太耗时.</p></li><li><p><strong>onDestroy</strong>: 表示 Activity 即将被销毁, 这是最后一个回调.</p></li></ol><p><img src=activity-lifecycle.png alt="Activity Life Cycle"></p><p>上图来源于: <a href=https://developer.android.google.cn/reference/android/app/Activity.html>https://developer.android.google.cn/reference/android/app/Activity.html</a></p><p>Activity 的生命周期回调方法分为一下几种情况:</p><ol><li><p>首次启动, <code>onCreate -> onStart -> onResume</code>.</p></li><li><p>当用户切换回桌面或其他 Activity 时, <code>onPause -> onStop</code>. 特殊情况: 如果新的 Activity 使用了透明主题, 那么当前 Activity 的 <code>onStop</code> 不会被调用.</p></li><li><p>用户再次回到这个 Activity 时, <code>onRestart -> onStart -> onResume</code>.</p></li><li><p>当用户按下 <code>返回键</code> 时, 默认情况下 Activity 会被销毁, <code>onPause -> onStop -> onDestroy</code>.</p></li><li><p><code>onCreate</code> 和 <code>onStop</code> 对应着 Activity 的 <code>创建</code> 与 <code>销毁</code>；<code>onStart</code> 和 <code>onStop</code> 对应着<code>可见</code>与<code>不可见</code>；<code>onResume</code> 和 <code>onPause</code> 对应着 <code>前台</code> 和 <code>后台</code>.</p></li></ol><h4 id=异常情况下-activity-的生命周期>异常情况下 Activity 的生命周期</h4><ol><li>系统资源发生改变</li></ol><p>比如屏幕方向发生变化时. 在默认情况下, Activity 会被销毁, 正常的生命周期方法会被调用, 并且 <code>onSaveInstanceState</code> 和 <code>onRestoreInstanceState</code> 会被额外调用, 用于保存和恢复当前状态.
<code>onSaveInstanceState</code>会在<code>onStop</code>之前被调用, <code>onRestoreInstanceState</code> 会在 <code>onStart</code> 之后被调用.
并且, Activity 会自动帮我们保存一些数据, 比如用户在文本框中输入的文本等等.
View 也有 <code>onSaveInstanceState</code> 和 <code>onRestoreInstanceState</code> 两个方法, 当 Activity 意外停止时, 他们会被调用.</p><ol start=2><li>系统资源不足导致 Activity 被销毁</li></ol><p>Activity 的优先级如下:</p><ol><li>前台 Activity, 即正在和用户交互的 Activity.</li><li>可见, 但是在后台的 Activity.</li><li>在后台的 Activity, 并且不可见.</li></ol><p>前台 Activity 最不容易被杀死.</p><p>在这种情况下, <code>onSaveInstanceState</code> 和 <code>onRestoreInstanceState</code> 也会被调用.</p><h3 id=activity-的启动模式-launch-mode>Activity 的启动模式 (Launch Mode)</h3><ol><li><p><strong>standard</strong>: 标准模式, 也是默认的模式. 可以有多个实例, 在哪个 Activity 栈中启动, 就会被至于那个栈中.</p></li><li><p><strong>singleTop</strong>: 这种模式下, 如果这个 Activtiy 处于栈顶的话, 再次启动这个 Activity 并不会启动一个新的实例, 而这个 Activity 的 <code>onNewIntent</code> 会被调用, 可以在这个方法里处理新的请求.</p><blockquote><p>“standard”和“singleTop”Activity 为一类, 使用“standard”或“singleTop”启动模式的 Activity 可多次实例化. 实例可归属任何任务, 并且可以位于 Activity 堆栈中的任何位置.</p></blockquote></li><li><p><strong>singleInstance</strong>: 该启动模式的 Activity 启动后会创建一个新的任务栈, 并且这个任务栈中始终只会有这一个实例, 如果再次启动, 不会创建新实例, 而 <code>onNewIntent</code> 会被调用.</p></li><li><p><strong>singleTask</strong>: 该模式也是一种单实例模式, 如果当前任务栈中不存在这个 Activity , 则会创建这个 Activity, 否则会将已存在的实例调到栈顶, 并且会清除掉原来所有的在该 Activity 之上的 Activity, 如下图:</p></li></ol><p><img src=mode-singleTask.gif alt="SingleTask Mode"></p><blockquote><p>“singleTask”和“singleInstance”模式同样只在一个方面有差异: “singleTask”Activity 允许其他 Activity 成为其任务的组成部分. 它始终位于其任务的根位置, 但其他 Activity（必然是“standard”和“singleTop”Activity）可以启动到该任务中. 相反, “singleInstance”Activity 则不允许其他 Activity 成为其任务的组成部分.</p></blockquote><p>另外, 在 <code>singleTop</code>, <code>singleTask</code>, <code>singleInstance</code> 在栈顶时, 再次启动该 Activity 时, 生命周期调用顺序为: <code>onPause -> onNewIntent -> onResume</code>.</p><h4 id=activity-flags>Activity Flags</h4><ol><li>FLAG_ACTIVITY_NEW_TASK</li></ol><p>这个 flag 效果与在 xml 中指定 <code>singleTask</code> 效果相同.</p><ol start=2><li>FLAG_ACTIVITY_SINGLE_TOP</li></ol><p>这个 flag 效果与在 xml 中指定 <code>singleTop</code> 效果相同.</p><ol start=3><li>FLAG_ACTIVITY_CLEAR_TOP</li></ol><p>具有此标记为的 Activity 在启动时, 在同一个任务栈中的所有位于它上面的 Activity 都要出栈.
一般这个 flag 与 FLAG_ACTIVITY_NEW_TASK 配合使用.
如果被启动的 Activity 是 <code>standard</code> 启动模式, 那么连同它自己以及它之上的 Activity 都要出栈.
系统会重新创建该 Activity 的实例, 并放入栈顶.</p><ol start=4><li>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</li></ol><p>这个 flag 可以使启动的 Activity 不在最近任务列表中显示.</p><h3 id=intentfilter-匹配规则>IntentFilter 匹配规则</h3><p>Activity 的启动分为 显式启动 和 隐式启动.</p><p>显式启动通过直接指定包名组件名直接启动对应的组件.</p><p>隐式启动不需要指定特定的包名或组件名, 可以通过某些信息匹配某些 Activity.</p><p>intent-filter 中有三种过滤信息, action, category, data, 而在 startActivity 时,
必须匹配这三个信息, 否则会匹配失败.
一个组件中可以有多个 intent-filter, 只要匹配到其中任意一个即可.</p><ul><li><p>action</p><p>action 的匹配要求 Intent 中的 action 字符串与过滤器中声明的相同, 并且区分大小写.
在单个 intent-filter 中可以定义多个 action, 而 Intent 中仅需要匹配到任意一个即可.</p></li><li><p>category</p><p>Intent 可以添加多个 category, Intent 中如果含有 category,
那么 Intent 中添加的 category 必须都在 intent-filter 中声明, 否则会匹配失败.</p><p>另外, 在 intent-filter 中必须添加一个 android.intent.category.DEFAULT, 否则它不会被任何 Intent 匹配到,
因为</p><blockquote><p>Android 会自动将 CATEGORY_DEFAULT 类别应用于传递给 startActivity() 和 startActivityForResult() 的所有隐式 Intent. 因此, 如需 Activity 接收隐式 Intent, 则必须将 &ldquo;android.intent.category.DEFAULT&rdquo; 的类别包括在其 Intent 过滤器中（如上文的 示例所示）.</p></blockquote></li><li><p>data</p><blockquote><p>使用一个或多个指定数据 URI 各个方面（scheme、host、port、path 等）和 MIME 类型的属性, 声明接受的数据类型.</p></blockquote><p>语法如下:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#e06c75>&lt;data</span> <span style=color:#e06c75>android:scheme=</span><span style=color:#98c379>&#34;string&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#e06c75>android:host=</span><span style=color:#98c379>&#34;string&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#e06c75>android:port=</span><span style=color:#98c379>&#34;string&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#e06c75>android:path=</span><span style=color:#98c379>&#34;string&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#e06c75>android:pathPattern=</span><span style=color:#98c379>&#34;string&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#e06c75>android:pathPrefix=</span><span style=color:#98c379>&#34;string&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#e06c75>android:mimeType=</span><span style=color:#98c379>&#34;string&#34;</span> <span style=color:#e06c75>/&gt;</span>
</span></span></code></pre></div><ul><li><p>scheme</p><p>URI 的模式, 比如 http, ftp, file, content 等, 这个是必选项, 如果不指定这个参数, 那么这个 URI 就是无效的.</p></li><li><p>host</p><p>URI 的主机名, 比如 <a href=https://www.google.com>www.google.com</a>, host 也是必须的.</p></li><li><p>port</p><p>主机的端口号, 比如 80.</p></li><li><p>path | pathPattern | pathPrefix</p><p>表示 URI 的路径, path 表示完整的路径, pathPattern 中可以包含通配符, pathPrefix 表示路径的前缀</p></li><li><p>mimeType</p><p>表示文件的类型, 比如 <code>image/png</code>, <code>text/html</code> 等等.</p></li></ul><p>在被启动的 Activity 中可以通过 <code>Intent#getData</code> 获取到匹配到的 URI.</p><p>在 Intent 中可以通过 <code>Intent#setData</code>, <code>Intent#setType</code> 设置 data 或 type.
如果需要同时设置 data 和 type 则需要调用 <code>Intent#setDataAndType</code>, 因为上面两个方法都会清空另一个的值.</p><p>如果 <code>intents-filters</code> 仅设置了 <code>mimeType</code>, 而没有设置 <code>scheme</code>, <code>scheme</code> 默认会是 <code>file</code> 或 <code>content</code>.</p></li></ul><p>在隐式启动过程中, 如果没有匹配到任何组件, 那么程序会报错停止运行.
通常需要在隐式启动时, 判断是否有 Activity 可以匹配到.</p><p>有两种方法:</p><ol><li>通过 <code>PackageManager</code> 的一系列 <code>resolve...()</code> 来查询, 如果可以匹配, 则会返回响应 Intent 的最佳组件, 否则就会返回 null.</li><li><code>PackageManager</code> 该提供了一系列的 <code>query...()</code> 的方法, 它会返回所有可以匹配的 Activity.</li></ol><blockquote><p>两种方法都不会直接激活组件, 而只是列出可以响应的组件.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#c678dd>public</span> <span style=color:#c678dd>abstract</span> <span style=color:#e06c75>List</span><span style=color:#56b6c2>&lt;</span><span style=color:#e06c75>ResolveInfo</span><span style=color:#56b6c2>&gt;</span> <span style=color:#61afef;font-weight:700>queryIntentActivities</span><span style=color:#56b6c2>(</span><span style=color:#e06c75>Intent</span> <span style=color:#e06c75>intent</span><span style=color:#56b6c2>,</span> <span style=color:#e5c07b>int</span> <span style=color:#e06c75>flags</span><span style=color:#56b6c2>);</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>public</span> <span style=color:#c678dd>abstract</span> <span style=color:#e06c75>ResolveInfo</span> <span style=color:#61afef;font-weight:700>resolveActivity</span><span style=color:#56b6c2>(</span><span style=color:#e06c75>Intent</span> <span style=color:#e06c75>intent</span><span style=color:#56b6c2>,</span> <span style=color:#e5c07b>int</span> <span style=color:#e06c75>flags</span><span style=color:#56b6c2>);</span>
</span></span></code></pre></div><p>注意第二个参数, 最好使用 MATCH_DEFAULT_ONLY</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#7f848e>/**
</span></span></span><span style=display:flex><span><span style=color:#7f848e> * Resolution and querying flag: if set, only filters that support the
</span></span></span><span style=display:flex><span><span style=color:#7f848e> * {@link android.content.Intent#CATEGORY_DEFAULT} will be considered for
</span></span></span><span style=display:flex><span><span style=color:#7f848e> * matching.  This is a synonym for including the CATEGORY_DEFAULT in your
</span></span></span><span style=display:flex><span><span style=color:#7f848e> * supplied Intent.
</span></span></span><span style=display:flex><span><span style=color:#7f848e> */</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>public</span> <span style=color:#c678dd>static</span> <span style=color:#c678dd>final</span> <span style=color:#e5c07b>int</span> <span style=color:#e06c75>MATCH_DEFAULT_ONLY</span>  <span style=color:#56b6c2>=</span> <span style=color:#d19a66>0x00010000</span><span style=color:#56b6c2>;</span>
</span></span></code></pre></div><p>这个标记的含义是仅仅匹配那些在 intents-filters 中声明了 android.intent.category.DEFAULT 的 Activity,
如果 Activity 没有声明这个 category, 使用 startActivity 将会报错.</p><p>参考资料:</p><p><a href=https://developer.android.google.cn/guide/topics/manifest/activity-element.html>https://developer.android.google.cn/guide/topics/manifest/activity-element.html</a></p><p><a href=https://inthecheesefactory.com/blog/understand-android-activity-launchmode/en>https://inthecheesefactory.com/blog/understand-android-activity-launchmode/en</a></p><p><a href=http://blog.csdn.net/javazejian/article/details/52072131>http://blog.csdn.net/javazejian/article/details/52072131</a></p><p><a href=https://developer.android.com/guide/components/intents-filters.html>https://developer.android.com/guide/components/intents-filters.html</a></p></section><footer class="mt-12 flex flex-wrap"><a class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]" href=tags/android/>#android</a>
<a class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]" href=tags/notes/>#notes</a></footer><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]"><a class="flex w-1/2 items-center rounded-l-md p-6 pr-3 no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=/2017/10/29/8086-assembly-01/><span class=mr-1.5>←</span><span>8086 汇编笔记 - 寄存器/寻址 - 01</span></a>
<a class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=/2017/10/20/hello-world/><span>Hello World</span><span class=ml-1.5>→</span></a></nav><div class=mt-24 id=disqus_thread></div><script>const disqusShortname="devldd",script=document.createElement("script");script.src="https://"+disqusShortname+".disqus.com/embed.js",script.setAttribute("data-timestamp",+new Date),document.head.appendChild(script)</script></article></main><footer class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2023
<a class=link href>Devld</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Theme Paper</a></footer></body></html>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Notes on Devld</title><link>/tags/notes/</link><description>Recent content in Notes on Devld</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Thu, 29 Mar 2018 20:28:00 +0800</lastBuildDate><atom:link href="/tags/notes/index.xml" rel="self" type="application/rss+xml"/><item><title>C++ 类与类继承</title><link>/2018/03/29/cpp-learning-01/</link><pubDate>Thu, 29 Mar 2018 20:28:00 +0800</pubDate><guid>/2018/03/29/cpp-learning-01/</guid><description>&lt;h3 id="构造函数与析构函数">构造函数与析构函数&lt;/h3>
&lt;h4 id="构造函数">构造函数&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>普通构造函数&lt;/p>
&lt;p>普通构造函数用来创建对象，如果该类位定义构造函数，则编译器会生成一个默认的空参数构造函数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>复制构造函数&lt;/p>
&lt;p>复制构造函数，顾名思义，用于复制一个对象，定义如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e06c75">Test&lt;/span>(&lt;span style="color:#c678dd">const&lt;/span> &lt;span style="color:#e06c75">Test&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&lt;/span>&lt;span style="color:#e06c75">t&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>转换构造函数&lt;/p>
&lt;p>转换构造函数，将某个类型转为这个类的类型，定义如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e06c75">Test&lt;/span>(&lt;span style="color:#c678dd">const&lt;/span> &lt;span style="color:#e5c07b">int&lt;/span> &lt;span style="color:#56b6c2">&amp;amp;&lt;/span>&lt;span style="color:#e06c75">a&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用转换构造函数可以实现类型的转换&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">// 调用转换构造函数，实例化一个 Test 对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span>&lt;span style="color:#e06c75">Test&lt;/span> &lt;span style="color:#e06c75">a&lt;/span> &lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#d19a66">42&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果不希望构造函数被用于隐式转换，可用 &lt;code>explicit&lt;/code> 关键字阻止隐式转换。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>使用类的默认构造函数创建对象时，可能会出现下面的问题:&lt;/p>
&lt;!-- more -->
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">// 创建一个 Test 类型的变量 a
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span>&lt;span style="color:#e06c75">Test&lt;/span> &lt;span style="color:#e06c75">test&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">// 声明了一个返回值为 Test 的函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">// 在 调用 a.fun() 时，会报错: 
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">// error: request for member &amp;#39;fun&amp;#39; in &amp;#39;a&amp;#39;, which is of non-class type &amp;#39;Test()&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span>&lt;span style="color:#e06c75">Test&lt;/span> &lt;span style="color:#61afef;font-weight:bold">a&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">// 动态创建对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span>&lt;span style="color:#e06c75">Test&lt;/span> &lt;span style="color:#56b6c2">*&lt;/span>&lt;span style="color:#e06c75">tp&lt;/span> &lt;span style="color:#56b6c2">=&lt;/span> &lt;span style="color:#c678dd">new&lt;/span> &lt;span style="color:#e06c75">Test&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">// 销毁动态创建的对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#7f848e">&lt;/span>&lt;span style="color:#c678dd">delete&lt;/span> &lt;span style="color:#e06c75">tp&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="析构函数">析构函数&lt;/h4>
&lt;p>正好与构造函数相反，用来在该对象被销毁时，释放资源。定义如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#56b6c2">~&lt;/span>&lt;span style="color:#e06c75">Test&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>非动态创建的对象会在合适的时刻由编译器自动调用析构函数销毁该对象，而由 &lt;code>new&lt;/code> 关键字创建的对象则需要手动使用 &lt;code>delete&lt;/code> 销毁对象释放内存。&lt;/p></description></item><item><title>8086 汇编笔记 - 常用指令 - 03</title><link>/2017/11/16/8086-assembly-03/</link><pubDate>Thu, 16 Nov 2017 12:47:00 +0800</pubDate><guid>/2017/11/16/8086-assembly-03/</guid><description>&lt;h3 id="数据传送">数据传送&lt;/h3>
&lt;ol>
&lt;li>MOV dest, src&lt;/li>
&lt;/ol>
&lt;p>将 src 中的数据传送至 dest.&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-x86asm" data-lang="x86asm">MOV AX, BX ; CPU 的通用寄存器之间的数据传送
MOV AX, 1234H ; 立即数 -&amp;gt; 寄存器
MOV DS:[1234H] 5678H ; 立即数 -&amp;gt; 存储单元

MOV AX, DS:[1234H] ; 存储单元 -&amp;gt; 寄存器
MOV DS:[1234H], BX ; 寄存器 -&amp;gt; 存储单元

MOV AX, ES ; 段寄存器 -&amp;gt; 通用寄存器
MOV DS, AX ; 通用寄存器 -&amp;gt; 段寄存器
MOV ES, DS:[BX] ; 存储单元 -&amp;gt; 段寄存器
MOV DS:[1234H], CS ; 段寄存器 -&amp;gt; 存储单元

MOV WORD PTR DS:[0], 12H ; 将 12H 当作 字型数据 放入 DS:[0]
&lt;/code>&lt;/pre> &lt;!-- more -->
&lt;p>使用 MOV 指令时需注意以下几点:&lt;/p></description></item><item><title>8086 汇编笔记 - 程序代码结构 - 02</title><link>/2017/10/29/8086-assembly-02/</link><pubDate>Sun, 29 Oct 2017 17:28:00 +0800</pubDate><guid>/2017/10/29/8086-assembly-02/</guid><description>&lt;blockquote>
&lt;p>这里的汇编是 16位汇编, 在 Win7 64位 及以后已经不支持
目前有两种方法: 一是使用虚拟机, 另外就是 安装一个 &lt;code>DosBox&lt;/code>
工具合集: &lt;a href="https://ss.devld.me/#/_/Sharing?h=download&amp;amp;e=AsmTools.zip">AsmTool.zip&lt;/a> 包含: masm 5和6 以及 DosBox&lt;/p>&lt;/blockquote>
&lt;p>先来一个 Hello World&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-x86asm" data-lang="x86asm">ASSUME CS:CODE ; 声明代码段

DATA SEGMENT ; 数据段
 HELLOWORLD DB &amp;#39;Hello World&amp;#39;, &amp;#39;$&amp;#39; ; HelloWorld 字符串
DATA ENDS

STACK SEGMENT STACK ; 堆栈段
 DB 32 DUP(0) ; 声明一个32 bytes的连续空间当作堆栈段
STACK ENDS

CODE SEGMENT ; 代码段
START:
 MOV AX, DATA 
 MOV DS, AX ; 设置 DS 为数据段

 MOV AH, 09H
 MOV DX, OFFSET HELLOWORLD
 INT 21H ; 调用 DOS 的中断, 将DX 指向的字符串打印出来

 MOV AX, 4C00H
 INT 21H ; 程序退出
CODE ENDS
END START ; 汇编结束, 并表示 程序起始位置为 标号 START 处
&lt;/code>&lt;/pre>&lt;p>简化版 (MASM 6.x+)&lt;/p></description></item><item><title>8086 汇编笔记 - 寄存器/寻址 - 01</title><link>/2017/10/29/8086-assembly-01/</link><pubDate>Sun, 29 Oct 2017 13:46:00 +0800</pubDate><guid>/2017/10/29/8086-assembly-01/</guid><description>&lt;h3 id="8086-寄存器">8086 寄存器&lt;/h3>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>寄存器&lt;/th>
 &lt;th>说明&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>AX (AH+AL)&lt;/td>
 &lt;td>累加器(Accumulator)&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>BX (BH+BL)&lt;/td>
 &lt;td>基地址寄存器(Base Register)&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>CX (CH+CL)&lt;/td>
 &lt;td>计数寄存器(Count Register)&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>DX (DH+DL)&lt;/td>
 &lt;td>数据寄存器(Data Register)&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>SP&lt;/td>
 &lt;td>堆栈指针寄存器, 指向栈顶(高地址)&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>BP&lt;/td>
 &lt;td>一般和SP 联合使用, 用于寻找堆栈数据而不破坏SP&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>SI&lt;/td>
 &lt;td>源变址寄存器&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>DI&lt;/td>
 &lt;td>目的变址寄存器&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>CS&lt;/td>
 &lt;td>代码段 段寄存器&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>DS&lt;/td>
 &lt;td>数据段 段寄存器&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>SS&lt;/td>
 &lt;td>堆栈段 段寄存器&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>ES&lt;/td>
 &lt;td>附加数据段 端寄存器, 一般在复制数据时配合DS 当作目的段寄存器使用&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>IP&lt;/td>
 &lt;td>指令指针, 指向下一条指令的地址&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>FLAGS&lt;/td>
 &lt;td>标志寄存器 (见下表)&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>标志寄存器&lt;/p>
&lt;!-- more -->
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>标志&lt;/th>
 &lt;th>说明&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>CF&lt;/td>
 &lt;td>进位标志 (Carry), 如果运算的最高为产生进位或借位, 则CF=1&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>PF&lt;/td>
 &lt;td>奇偶位 (Parity), 如果运算结果的低8 位中的1的个数(二进制)为偶数个, 则PF=1&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>AF&lt;/td>
 &lt;td>辅助进位标志 (Auxiliary), 当运算结果的低4 位产生一个进位或借位, 则AF=1&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>ZF&lt;/td>
 &lt;td>零标志 (Zero), 若运算结果为0, 则ZF=1&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>SF&lt;/td>
 &lt;td>符号标志 (Signed), 当数据用补码表示时, 最高为表示符号为, SF与运算结果最高为相同&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>OF&lt;/td>
 &lt;td>溢出标志 (Overflow), 若运算中产生了溢出, 则OF=1&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>DF&lt;/td>
 &lt;td>方向标志 (Direction), 用于控制串操作指令, 如果DF=0, 则串操作过程中地址会增大, 否则地址会减小&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>IF&lt;/td>
 &lt;td>中断允许标志 (Interrupt), 若IF=0, 则CPU不能对可屏蔽中断做出响应, 否则CPU可以接受可屏蔽中断&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>TF&lt;/td>
 &lt;td>单步标志 (Trap), 如果TF=1, 则CPU按跟踪方式执行指令&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>&lt;img src="8086-flags-reg.png" alt="flags">&lt;/p></description></item><item><title>《Android 开发艺术探索》笔记 - Activity - 01</title><link>/2017/10/24/android-dev-art-note-01/</link><pubDate>Tue, 24 Oct 2017 17:56:00 +0800</pubDate><guid>/2017/10/24/android-dev-art-note-01/</guid><description>&lt;h3 id="activity-生命周期">Activity 生命周期&lt;/h3>
&lt;h4 id="正常情况下-activity-的生命周期">正常情况下 Activity 的生命周期&lt;/h4>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>onCreate&lt;/strong>: 表示 Activity 正在被创建, 主要在这个方法中做一些初始化.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>onRestart&lt;/strong>: 表示 Activity 正在重新启动, 一般情况下, 当 Activity 从不可见变为可见时会被调用.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>onStart&lt;/strong>: 表示 Activity 正在启动, 但还无法与用户交互, 此时 Activity 还在后台.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>onResume&lt;/strong>: 表示 Activity 已经可见了, 和 onStart 的区别是现在 Activity 处于前台.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>onPause&lt;/strong>: 当其他 Activity 进入前台时会被调用, 这个方法里不能执行耗时的操作, 否则会影响新 Activity 的启动, 因为新 Activity 的 onResume 会在这个 Activity 的 onPause 执行完成后才会被调用.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>onStop&lt;/strong>: 表示 Activity 即将停止, 可以做一些回收工作, 但也不能太耗时.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>onDestroy&lt;/strong>: 表示 Activity 即将被销毁, 这是最后一个回调.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;!-- more -->
&lt;p>&lt;img src="activity-lifecycle.png" alt="Activity Life Cycle">&lt;/p>
&lt;p>上图来源于: &lt;a href="https://developer.android.google.cn/reference/android/app/Activity.html">https://developer.android.google.cn/reference/android/app/Activity.html&lt;/a>&lt;/p></description></item></channel></rss>
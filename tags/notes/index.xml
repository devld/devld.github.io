<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>notes on Devld</title><link>/tags/notes/</link><description>Recent content in notes on Devld</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 29 Mar 2018 20:28:00 +0800</lastBuildDate><atom:link href="/tags/notes/index.xml" rel="self" type="application/rss+xml"/><item><title>C++ 类与类继承</title><link>/2018/03/29/cpp-learning-01/</link><pubDate>Thu, 29 Mar 2018 20:28:00 +0800</pubDate><guid>/2018/03/29/cpp-learning-01/</guid><description>构造函数与析构函数 构造函数 普通构造函数
普通构造函数用来创建对象，如果该类位定义构造函数，则编译器会生成一个默认的空参数构造函数。
复制构造函数
复制构造函数，顾名思义，用于复制一个对象，定义如下:
Test(const Test &amp;amp;t); 转换构造函数
转换构造函数，将某个类型转为这个类的类型，定义如下:
Test(const int &amp;amp;a); 使用转换构造函数可以实现类型的转换
// 调用转换构造函数，实例化一个 Test 对象 Test a = 42; 如果不希望构造函数被用于隐式转换，可用 explicit 关键字阻止隐式转换。
使用类的默认构造函数创建对象时，可能会出现下面的问题:
// 创建一个 Test 类型的变量 a Test test; // 声明了一个返回值为 Test 的函数 // 在 调用 a.fun() 时，会报错: // error: request for member &amp;#39;fun&amp;#39; in &amp;#39;a&amp;#39;, which is of non-class type &amp;#39;Test()&amp;#39; Test a(); // 动态创建对象 Test *tp = new Test(); // 销毁动态创建的对象 delete tp; 析构函数 正好与构造函数相反，用来在该对象被销毁时，释放资源。定义如下:</description></item><item><title>8086 汇编笔记 - 常用指令 - 03</title><link>/2017/11/16/8086-assembly-03/</link><pubDate>Thu, 16 Nov 2017 12:47:00 +0800</pubDate><guid>/2017/11/16/8086-assembly-03/</guid><description>数据传送 MOV dest, src 将 src 中的数据传送至 dest.
MOV AX, BX ; CPU 的通用寄存器之间的数据传送 MOV AX, 1234H ; 立即数 -&amp;gt; 寄存器 MOV DS:[1234H] 5678H ; 立即数 -&amp;gt; 存储单元 MOV AX, DS:[1234H] ; 存储单元 -&amp;gt; 寄存器 MOV DS:[1234H], BX ; 寄存器 -&amp;gt; 存储单元 MOV AX, ES ; 段寄存器 -&amp;gt; 通用寄存器 MOV DS, AX ; 通用寄存器 -&amp;gt; 段寄存器 MOV ES, DS:[BX] ; 存储单元 -&amp;gt; 段寄存器 MOV DS:[1234H], CS ; 段寄存器 -&amp;gt; 存储单元 MOV WORD PTR DS:[0], 12H ; 将 12H 当作 字型数据 放入 DS:[0] 使用 MOV 指令时需注意以下几点:</description></item><item><title>8086 汇编笔记 - 程序代码结构 - 02</title><link>/2017/10/29/8086-assembly-02/</link><pubDate>Sun, 29 Oct 2017 17:28:00 +0800</pubDate><guid>/2017/10/29/8086-assembly-02/</guid><description>这里的汇编是 16位汇编, 在 Win7 64位 及以后已经不支持 目前有两种方法: 一是使用虚拟机, 另外就是 安装一个 DosBox 工具合集: AsmTool.zip 包含: masm 5和6 以及 DosBox
先来一个 Hello World
ASSUME CS:CODE ; 声明代码段 DATA SEGMENT ; 数据段 HELLOWORLD DB &amp;#39;Hello World&amp;#39;, &amp;#39;$&amp;#39; ; HelloWorld 字符串 DATA ENDS STACK SEGMENT STACK ; 堆栈段 DB 32 DUP(0) ; 声明一个32 bytes的连续空间当作堆栈段 STACK ENDS CODE SEGMENT ; 代码段 START: MOV AX, DATA MOV DS, AX ; 设置 DS 为数据段 MOV AH, 09H MOV DX, OFFSET HELLOWORLD INT 21H ; 调用 DOS 的中断, 将DX 指向的字符串打印出来 MOV AX, 4C00H INT 21H ; 程序退出 CODE ENDS END START ; 汇编结束, 并表示 程序起始位置为 标号 START 处 简化版 (MASM 6.</description></item><item><title>8086 汇编笔记 - 寄存器/寻址 - 01</title><link>/2017/10/29/8086-assembly-01/</link><pubDate>Sun, 29 Oct 2017 13:46:00 +0800</pubDate><guid>/2017/10/29/8086-assembly-01/</guid><description>8086 寄存器 寄存器 说明 AX (AH+AL) 累加器(Accumulator) BX (BH+BL) 基地址寄存器(Base Register) CX (CH+CL) 计数寄存器(Count Register) DX (DH+DL) 数据寄存器(Data Register) SP 堆栈指针寄存器, 指向栈顶(高地址) BP 一般和SP 联合使用, 用于寻找堆栈数据而不破坏SP SI 源变址寄存器 DI 目的变址寄存器 CS 代码段 段寄存器 DS 数据段 段寄存器 SS 堆栈段 段寄存器 ES 附加数据段 端寄存器, 一般在复制数据时配合DS 当作目的段寄存器使用 IP 指令指针, 指向下一条指令的地址 FLAGS 标志寄存器 (见下表) 标志寄存器
标志 说明 CF 进位标志 (Carry), 如果运算的最高为产生进位或借位, 则CF=1 PF 奇偶位 (Parity), 如果运算结果的低8 位中的1的个数(二进制)为偶数个, 则PF=1 AF 辅助进位标志 (Auxiliary), 当运算结果的低4 位产生一个进位或借位, 则AF=1 ZF 零标志 (Zero), 若运算结果为0, 则ZF=1 SF 符号标志 (Signed), 当数据用补码表示时, 最高为表示符号为, SF与运算结果最高为相同 OF 溢出标志 (Overflow), 若运算中产生了溢出, 则OF=1 DF 方向标志 (Direction), 用于控制串操作指令, 如果DF=0, 则串操作过程中地址会增大, 否则地址会减小 IF 中断允许标志 (Interrupt), 若IF=0, 则CPU不能对可屏蔽中断做出响应, 否则CPU可以接受可屏蔽中断 TF 单步标志 (Trap), 如果TF=1, 则CPU按跟踪方式执行指令 数据寻址方式 立即寻址 操作数包含在指令中</description></item><item><title>《Android 开发艺术探索》笔记 - Activity - 01</title><link>/2017/10/24/android-dev-art-note-01/</link><pubDate>Tue, 24 Oct 2017 17:56:00 +0800</pubDate><guid>/2017/10/24/android-dev-art-note-01/</guid><description>Activity 生命周期 正常情况下 Activity 的生命周期 onCreate: 表示 Activity 正在被创建, 主要在这个方法中做一些初始化.
onRestart: 表示 Activity 正在重新启动, 一般情况下, 当 Activity 从不可见变为可见时会被调用.
onStart: 表示 Activity 正在启动, 但还无法与用户交互, 此时 Activity 还在后台.
onResume: 表示 Activity 已经可见了, 和 onStart 的区别是现在 Activity 处于前台.
onPause: 当其他 Activity 进入前台时会被调用, 这个方法里不能执行耗时的操作, 否则会影响新 Activity 的启动, 因为新 Activity 的 onResume 会在这个 Activity 的 onPause 执行完成后才会被调用.
onStop: 表示 Activity 即将停止, 可以做一些回收工作, 但也不能太耗时.
onDestroy: 表示 Activity 即将被销毁, 这是最后一个回调.
上图来源于: https://developer.android.google.cn/reference/android/app/Activity.html
Activity 的生命周期回调方法分为一下几种情况:
首次启动, onCreate -&amp;gt; onStart -&amp;gt; onResume.</description></item></channel></rss>
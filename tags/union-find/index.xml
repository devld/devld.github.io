<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>union-find on Devld</title><link>/tags/union-find/</link><description>Recent content in union-find on Devld</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 27 Dec 2017 10:00:00 +0800</lastBuildDate><atom:link href="/tags/union-find/index.xml" rel="self" type="application/rss+xml"/><item><title>并查集(Union-Find) 判断连通性</title><link>/2017/12/27/union-find/</link><pubDate>Wed, 27 Dec 2017 10:00:00 +0800</pubDate><guid>/2017/12/27/union-find/</guid><description>有如下的一些点
每次连接其中两个点，然后判断任意两个点是否连通。
比如上图中的 0 和 1，3 和 9 等等都是连通的，而 2 和 8 不连通。
只有这么一些点，当然好判断，但如果有这么多呢
那么，如何通过算法来判断其中两个点是否是连通的呢？
如下图的状态，我们可以将其看作是三个组件(component)。
判断两个点是否连通，直接判断它们是否在同一个组件中即可。 并为每个组件设置一个 id。
设置一个数组，用来标识这个组件的 id
初始状态下，所有点都是孤立状态，所以它们所在组件的 id 就是它们本身； 当两个点被连接后，将其中一个点的_标识_更改为另一个点的_标识_； 而当连接两个组件(含一个以上的点)时，可以将其中一个组件中的所有点的标识更改为另一个组件的标识。
当判断两个点是否连接时，直接判断他们是否在同一个组件内。
定义如下的方法
public class UnionFind1 { private int[] ids; public void union(int p, int q) { int pid = ids[p]; int qid = ids[q]; for (int i = 0; i &amp;lt; ids.length; i++) { // 将所有属于 pid 的组件更换为 qid if (pid == ids[i]) { ids[i] = qid; } } } // 省略其他方法 } 测试一下</description></item></channel></rss>